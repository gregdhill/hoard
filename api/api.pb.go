// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

package api

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grant "github.com/monax/hoard/v5/grant"
	reference "github.com/monax/hoard/v5/reference"
	stores "github.com/monax/hoard/v5/stores"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GrantAndGrantSpec struct {
	Grant *grant.Grant `protobuf:"bytes,1,opt,name=Grant,proto3" json:"Grant,omitempty"`
	// The type of grant to output
	GrantSpec            *grant.Spec `protobuf:"bytes,2,opt,name=GrantSpec,proto3" json:"GrantSpec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GrantAndGrantSpec) Reset()         { *m = GrantAndGrantSpec{} }
func (m *GrantAndGrantSpec) String() string { return proto.CompactTextString(m) }
func (*GrantAndGrantSpec) ProtoMessage()    {}
func (*GrantAndGrantSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *GrantAndGrantSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GrantAndGrantSpec.Unmarshal(m, b)
}
func (m *GrantAndGrantSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GrantAndGrantSpec.Marshal(b, m, deterministic)
}
func (m *GrantAndGrantSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GrantAndGrantSpec.Merge(m, src)
}
func (m *GrantAndGrantSpec) XXX_Size() int {
	return xxx_messageInfo_GrantAndGrantSpec.Size(m)
}
func (m *GrantAndGrantSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_GrantAndGrantSpec.DiscardUnknown(m)
}

var xxx_messageInfo_GrantAndGrantSpec proto.InternalMessageInfo

func (m *GrantAndGrantSpec) GetGrant() *grant.Grant {
	if m != nil {
		return m.Grant
	}
	return nil
}

func (m *GrantAndGrantSpec) GetGrantSpec() *grant.Spec {
	if m != nil {
		return m.GrantSpec
	}
	return nil
}

type PlaintextAndGrantSpec struct {
	// Types that are valid to be assigned to Input:
	//	*PlaintextAndGrantSpec_Plaintext
	//	*PlaintextAndGrantSpec_GrantSpec
	Input                isPlaintextAndGrantSpec_Input `protobuf_oneof:"input"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *PlaintextAndGrantSpec) Reset()         { *m = PlaintextAndGrantSpec{} }
func (m *PlaintextAndGrantSpec) String() string { return proto.CompactTextString(m) }
func (*PlaintextAndGrantSpec) ProtoMessage()    {}
func (*PlaintextAndGrantSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *PlaintextAndGrantSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlaintextAndGrantSpec.Unmarshal(m, b)
}
func (m *PlaintextAndGrantSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlaintextAndGrantSpec.Marshal(b, m, deterministic)
}
func (m *PlaintextAndGrantSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaintextAndGrantSpec.Merge(m, src)
}
func (m *PlaintextAndGrantSpec) XXX_Size() int {
	return xxx_messageInfo_PlaintextAndGrantSpec.Size(m)
}
func (m *PlaintextAndGrantSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaintextAndGrantSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PlaintextAndGrantSpec proto.InternalMessageInfo

type isPlaintextAndGrantSpec_Input interface {
	isPlaintextAndGrantSpec_Input()
}

type PlaintextAndGrantSpec_Plaintext struct {
	Plaintext *Plaintext `protobuf:"bytes,1,opt,name=Plaintext,proto3,oneof"`
}
type PlaintextAndGrantSpec_GrantSpec struct {
	GrantSpec *grant.Spec `protobuf:"bytes,2,opt,name=GrantSpec,proto3,oneof"`
}

func (*PlaintextAndGrantSpec_Plaintext) isPlaintextAndGrantSpec_Input() {}
func (*PlaintextAndGrantSpec_GrantSpec) isPlaintextAndGrantSpec_Input() {}

func (m *PlaintextAndGrantSpec) GetInput() isPlaintextAndGrantSpec_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *PlaintextAndGrantSpec) GetPlaintext() *Plaintext {
	if x, ok := m.GetInput().(*PlaintextAndGrantSpec_Plaintext); ok {
		return x.Plaintext
	}
	return nil
}

func (m *PlaintextAndGrantSpec) GetGrantSpec() *grant.Spec {
	if x, ok := m.GetInput().(*PlaintextAndGrantSpec_GrantSpec); ok {
		return x.GrantSpec
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PlaintextAndGrantSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PlaintextAndGrantSpec_Plaintext)(nil),
		(*PlaintextAndGrantSpec_GrantSpec)(nil),
	}
}

type ReferenceAndGrantSpec struct {
	Reference *reference.Ref `protobuf:"bytes,1,opt,name=Reference,proto3" json:"Reference,omitempty"`
	// The type of grant to output
	GrantSpec            *grant.Spec `protobuf:"bytes,2,opt,name=GrantSpec,proto3" json:"GrantSpec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ReferenceAndGrantSpec) Reset()         { *m = ReferenceAndGrantSpec{} }
func (m *ReferenceAndGrantSpec) String() string { return proto.CompactTextString(m) }
func (*ReferenceAndGrantSpec) ProtoMessage()    {}
func (*ReferenceAndGrantSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *ReferenceAndGrantSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReferenceAndGrantSpec.Unmarshal(m, b)
}
func (m *ReferenceAndGrantSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReferenceAndGrantSpec.Marshal(b, m, deterministic)
}
func (m *ReferenceAndGrantSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReferenceAndGrantSpec.Merge(m, src)
}
func (m *ReferenceAndGrantSpec) XXX_Size() int {
	return xxx_messageInfo_ReferenceAndGrantSpec.Size(m)
}
func (m *ReferenceAndGrantSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ReferenceAndGrantSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ReferenceAndGrantSpec proto.InternalMessageInfo

func (m *ReferenceAndGrantSpec) GetReference() *reference.Ref {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *ReferenceAndGrantSpec) GetGrantSpec() *grant.Spec {
	if m != nil {
		return m.GrantSpec
	}
	return nil
}

type Plaintext struct {
	// Types that are valid to be assigned to Input:
	//	*Plaintext_Data
	//	*Plaintext_Salt
	Input                isPlaintext_Input `protobuf_oneof:"input"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Plaintext) Reset()         { *m = Plaintext{} }
func (m *Plaintext) String() string { return proto.CompactTextString(m) }
func (*Plaintext) ProtoMessage()    {}
func (*Plaintext) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *Plaintext) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Plaintext.Unmarshal(m, b)
}
func (m *Plaintext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Plaintext.Marshal(b, m, deterministic)
}
func (m *Plaintext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plaintext.Merge(m, src)
}
func (m *Plaintext) XXX_Size() int {
	return xxx_messageInfo_Plaintext.Size(m)
}
func (m *Plaintext) XXX_DiscardUnknown() {
	xxx_messageInfo_Plaintext.DiscardUnknown(m)
}

var xxx_messageInfo_Plaintext proto.InternalMessageInfo

type isPlaintext_Input interface {
	isPlaintext_Input()
}

type Plaintext_Data struct {
	Data []byte `protobuf:"bytes,1,opt,name=Data,proto3,oneof"`
}
type Plaintext_Salt struct {
	Salt []byte `protobuf:"bytes,2,opt,name=Salt,proto3,oneof"`
}

func (*Plaintext_Data) isPlaintext_Input() {}
func (*Plaintext_Salt) isPlaintext_Input() {}

func (m *Plaintext) GetInput() isPlaintext_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *Plaintext) GetData() []byte {
	if x, ok := m.GetInput().(*Plaintext_Data); ok {
		return x.Data
	}
	return nil
}

func (m *Plaintext) GetSalt() []byte {
	if x, ok := m.GetInput().(*Plaintext_Salt); ok {
		return x.Salt
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Plaintext) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Plaintext_Data)(nil),
		(*Plaintext_Salt)(nil),
	}
}

type Ciphertext struct {
	EncryptedData        []byte   `protobuf:"bytes,1,opt,name=EncryptedData,proto3" json:"EncryptedData,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ciphertext) Reset()         { *m = Ciphertext{} }
func (m *Ciphertext) String() string { return proto.CompactTextString(m) }
func (*Ciphertext) ProtoMessage()    {}
func (*Ciphertext) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *Ciphertext) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ciphertext.Unmarshal(m, b)
}
func (m *Ciphertext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ciphertext.Marshal(b, m, deterministic)
}
func (m *Ciphertext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ciphertext.Merge(m, src)
}
func (m *Ciphertext) XXX_Size() int {
	return xxx_messageInfo_Ciphertext.Size(m)
}
func (m *Ciphertext) XXX_DiscardUnknown() {
	xxx_messageInfo_Ciphertext.DiscardUnknown(m)
}

var xxx_messageInfo_Ciphertext proto.InternalMessageInfo

func (m *Ciphertext) GetEncryptedData() []byte {
	if m != nil {
		return m.EncryptedData
	}
	return nil
}

type ReferenceAndCiphertext struct {
	Reference            *reference.Ref `protobuf:"bytes,1,opt,name=Reference,proto3" json:"Reference,omitempty"`
	Ciphertext           *Ciphertext    `protobuf:"bytes,2,opt,name=Ciphertext,proto3" json:"Ciphertext,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ReferenceAndCiphertext) Reset()         { *m = ReferenceAndCiphertext{} }
func (m *ReferenceAndCiphertext) String() string { return proto.CompactTextString(m) }
func (*ReferenceAndCiphertext) ProtoMessage()    {}
func (*ReferenceAndCiphertext) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *ReferenceAndCiphertext) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReferenceAndCiphertext.Unmarshal(m, b)
}
func (m *ReferenceAndCiphertext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReferenceAndCiphertext.Marshal(b, m, deterministic)
}
func (m *ReferenceAndCiphertext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReferenceAndCiphertext.Merge(m, src)
}
func (m *ReferenceAndCiphertext) XXX_Size() int {
	return xxx_messageInfo_ReferenceAndCiphertext.Size(m)
}
func (m *ReferenceAndCiphertext) XXX_DiscardUnknown() {
	xxx_messageInfo_ReferenceAndCiphertext.DiscardUnknown(m)
}

var xxx_messageInfo_ReferenceAndCiphertext proto.InternalMessageInfo

func (m *ReferenceAndCiphertext) GetReference() *reference.Ref {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *ReferenceAndCiphertext) GetCiphertext() *Ciphertext {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

type Address struct {
	Address              []byte   `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Address) Reset()         { *m = Address{} }
func (m *Address) String() string { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()    {}
func (*Address) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *Address) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Address.Unmarshal(m, b)
}
func (m *Address) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Address.Marshal(b, m, deterministic)
}
func (m *Address) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Address.Merge(m, src)
}
func (m *Address) XXX_Size() int {
	return xxx_messageInfo_Address.Size(m)
}
func (m *Address) XXX_DiscardUnknown() {
	xxx_messageInfo_Address.DiscardUnknown(m)
}

var xxx_messageInfo_Address proto.InternalMessageInfo

func (m *Address) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func init() {
	proto.RegisterType((*GrantAndGrantSpec)(nil), "api.GrantAndGrantSpec")
	proto.RegisterType((*PlaintextAndGrantSpec)(nil), "api.PlaintextAndGrantSpec")
	proto.RegisterType((*ReferenceAndGrantSpec)(nil), "api.ReferenceAndGrantSpec")
	proto.RegisterType((*Plaintext)(nil), "api.Plaintext")
	proto.RegisterType((*Ciphertext)(nil), "api.Ciphertext")
	proto.RegisterType((*ReferenceAndCiphertext)(nil), "api.ReferenceAndCiphertext")
	proto.RegisterType((*Address)(nil), "api.Address")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 548 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x4d, 0x6b, 0xdb, 0x40,
	0x10, 0x8d, 0x12, 0xc7, 0xc6, 0x13, 0xb5, 0x69, 0x97, 0x26, 0x18, 0x95, 0xd2, 0xa2, 0x86, 0xc4,
	0xfd, 0x40, 0x32, 0x2e, 0x81, 0x1e, 0x9b, 0xc4, 0x25, 0xe9, 0x4d, 0xac, 0xe8, 0xa5, 0xd0, 0xc3,
	0xda, 0x1a, 0xdb, 0x02, 0x65, 0x25, 0x56, 0xab, 0x36, 0x3d, 0x14, 0xfa, 0x57, 0x7a, 0xec, 0xbf,
	0x2c, 0xbb, 0x92, 0xf5, 0x69, 0x02, 0x39, 0xd9, 0xf3, 0xe6, 0xcd, 0xcc, 0x7b, 0x3b, 0x83, 0x60,
	0xc8, 0x92, 0xd0, 0x49, 0x44, 0x2c, 0x63, 0xb2, 0xc7, 0x92, 0xd0, 0x3a, 0x14, 0xb8, 0x44, 0x81,
	0x7c, 0x81, 0x39, 0x6a, 0x1d, 0xac, 0x04, 0xe3, 0xb2, 0x08, 0xcc, 0x54, 0xc6, 0x02, 0xd3, 0x3c,
	0xb2, 0xe7, 0xf0, 0xf4, 0x5a, 0x25, 0x2f, 0x78, 0xa0, 0x7f, 0xfd, 0x04, 0x17, 0xc4, 0x86, 0x7d,
	0x1d, 0x8c, 0x8c, 0x57, 0xc6, 0xf8, 0x60, 0x6a, 0x3a, 0x79, 0xbd, 0xc6, 0x68, 0x9e, 0x22, 0x6f,
	0x60, 0x58, 0x16, 0x8c, 0x76, 0x35, 0xef, 0xa0, 0xe0, 0x29, 0x88, 0x56, 0x59, 0xfb, 0x37, 0x1c,
	0x79, 0x11, 0x0b, 0xb9, 0xc4, 0xbb, 0xe6, 0x1c, 0x07, 0x86, 0x65, 0xa2, 0x98, 0xf5, 0xd8, 0x51,
	0x66, 0x4a, 0xf4, 0x66, 0x87, 0x56, 0x14, 0xf2, 0xee, 0xfe, 0x99, 0x8a, 0x5c, 0xe6, 0x2f, 0x07,
	0xb0, 0x1f, 0xf2, 0x24, 0x93, 0x76, 0x02, 0x47, 0x74, 0xf3, 0x20, 0x8d, 0xf1, 0xef, 0x61, 0x58,
	0x26, 0xca, 0xf1, 0xd5, 0xdb, 0x51, 0x5c, 0xd2, 0x8a, 0xf0, 0x10, 0xc3, 0x9f, 0x6a, 0xbe, 0xc8,
	0x33, 0xe8, 0xcd, 0x98, 0x64, 0x7a, 0x80, 0x79, 0xb3, 0x43, 0x75, 0xa4, 0x50, 0x9f, 0x45, 0x52,
	0x37, 0xd2, 0xa8, 0x8a, 0x2a, 0xcd, 0x53, 0x80, 0xab, 0x30, 0x59, 0xa3, 0xd0, 0x2d, 0x4e, 0xe0,
	0xd1, 0x67, 0xbe, 0x10, 0xbf, 0x12, 0x89, 0x41, 0xd5, 0x8b, 0x36, 0x41, 0xfb, 0x27, 0x1c, 0xd7,
	0x7d, 0xd6, 0xea, 0x1f, 0x66, 0xd4, 0xad, 0xcf, 0x2e, 0x9c, 0x1e, 0xea, 0xb5, 0x54, 0x30, 0xad,
	0x51, 0xec, 0xd7, 0x30, 0xb8, 0x08, 0x02, 0x81, 0x69, 0x4a, 0x46, 0xe5, 0xdf, 0x42, 0xe3, 0x26,
	0x9c, 0xfe, 0xdd, 0x2d, 0x8e, 0x8a, 0x4c, 0xa0, 0xe7, 0x23, 0x8b, 0x88, 0xa5, 0x7b, 0x6e, 0x5d,
	0x8d, 0xd5, 0x38, 0x39, 0x72, 0x0a, 0xfd, 0xaf, 0x3c, 0x55, 0x35, 0x0d, 0xdc, 0x6a, 0x99, 0x20,
	0x0e, 0xf4, 0x29, 0x6a, 0xde, 0xb1, 0xee, 0xdd, 0xb9, 0xec, 0x56, 0xdf, 0x73, 0x18, 0x78, 0x99,
	0xac, 0x89, 0xd9, 0x7a, 0xa6, 0xcd, 0xa2, 0xb1, 0xa1, 0xce, 0x30, 0x97, 0x73, 0x8d, 0xb2, 0xa3,
	0xa8, 0xd1, 0x66, 0x62, 0x90, 0xb7, 0x60, 0xe6, 0xe4, 0x19, 0x46, 0x28, 0xb1, 0xc5, 0x37, 0x35,
	0x7f, 0xf3, 0x46, 0xdf, 0x61, 0x78, 0x15, 0x21, 0xcb, 0x97, 0x76, 0x06, 0x7b, 0x5e, 0x26, 0x49,
	0xab, 0x63, 0xdb, 0xf3, 0xd8, 0x50, 0x44, 0x25, 0xa4, 0x95, 0xe8, 0x4a, 0x99, 0xfe, 0x31, 0x00,
	0x8a, 0x93, 0x09, 0x63, 0x4e, 0x3e, 0xc2, 0xa0, 0x88, 0x3a, 0x43, 0x9e, 0x77, 0x56, 0x53, 0xad,
	0x7b, 0x6c, 0xa8, 0xca, 0x19, 0xe6, 0x95, 0xf7, 0x31, 0xb7, 0x48, 0xf8, 0x67, 0xc0, 0xc0, 0x97,
	0xb1, 0x60, 0x2b, 0x24, 0x67, 0xd0, 0xf3, 0xb2, 0x74, 0x4d, 0xda, 0xb7, 0xd5, 0x7c, 0x14, 0x6d,
	0xb0, 0xe7, 0x65, 0x91, 0x5a, 0x7e, 0x0d, 0xb7, 0xda, 0x65, 0x13, 0x83, 0x9c, 0x42, 0xcf, 0x97,
	0x4c, 0xb6, 0x88, 0x4f, 0x9c, 0xe2, 0x8b, 0xa7, 0x72, 0x5f, 0xf8, 0x32, 0x26, 0x27, 0xd0, 0x2f,
	0xb7, 0x51, 0x67, 0x36, 0xa2, 0xcb, 0x97, 0xdf, 0x5e, 0xac, 0x42, 0xb9, 0xce, 0xe6, 0xce, 0x22,
	0xbe, 0x75, 0x6f, 0x63, 0xce, 0xee, 0xdc, 0x75, 0xcc, 0x44, 0xe0, 0xfe, 0x38, 0x77, 0x59, 0x12,
	0xce, 0xfb, 0xfa, 0x13, 0xfa, 0xe1, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x3a, 0x48, 0xa2, 0xfa,
	0x80, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GrantClient is the client API for Grant service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GrantClient interface {
	// Seal a Reference to create a Grant
	Seal(ctx context.Context, in *ReferenceAndGrantSpec, opts ...grpc.CallOption) (*grant.Grant, error)
	// Unseal a Grant to recover the Reference
	Unseal(ctx context.Context, in *grant.Grant, opts ...grpc.CallOption) (*reference.Ref, error)
	// Convert one grant to another grant to re-share with another party or just
	// to change grant type
	Reseal(ctx context.Context, in *GrantAndGrantSpec, opts ...grpc.CallOption) (*grant.Grant, error)
	// Put a Plaintext and returned the sealed Reference as a Grant
	PutSeal(ctx context.Context, opts ...grpc.CallOption) (Grant_PutSealClient, error)
	// Unseal a Grant and follow the Reference to return a Plaintext
	UnsealGet(ctx context.Context, in *grant.Grant, opts ...grpc.CallOption) (Grant_UnsealGetClient, error)
	// Unseal a Grant and follow the Reference to delete the Plaintext
	UnsealDelete(ctx context.Context, in *grant.Grant, opts ...grpc.CallOption) (*Address, error)
}

type grantClient struct {
	cc *grpc.ClientConn
}

func NewGrantClient(cc *grpc.ClientConn) GrantClient {
	return &grantClient{cc}
}

func (c *grantClient) Seal(ctx context.Context, in *ReferenceAndGrantSpec, opts ...grpc.CallOption) (*grant.Grant, error) {
	out := new(grant.Grant)
	err := c.cc.Invoke(ctx, "/api.Grant/Seal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grantClient) Unseal(ctx context.Context, in *grant.Grant, opts ...grpc.CallOption) (*reference.Ref, error) {
	out := new(reference.Ref)
	err := c.cc.Invoke(ctx, "/api.Grant/Unseal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grantClient) Reseal(ctx context.Context, in *GrantAndGrantSpec, opts ...grpc.CallOption) (*grant.Grant, error) {
	out := new(grant.Grant)
	err := c.cc.Invoke(ctx, "/api.Grant/Reseal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grantClient) PutSeal(ctx context.Context, opts ...grpc.CallOption) (Grant_PutSealClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Grant_serviceDesc.Streams[0], "/api.Grant/PutSeal", opts...)
	if err != nil {
		return nil, err
	}
	x := &grantPutSealClient{stream}
	return x, nil
}

type Grant_PutSealClient interface {
	Send(*PlaintextAndGrantSpec) error
	CloseAndRecv() (*grant.Grant, error)
	grpc.ClientStream
}

type grantPutSealClient struct {
	grpc.ClientStream
}

func (x *grantPutSealClient) Send(m *PlaintextAndGrantSpec) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grantPutSealClient) CloseAndRecv() (*grant.Grant, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(grant.Grant)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grantClient) UnsealGet(ctx context.Context, in *grant.Grant, opts ...grpc.CallOption) (Grant_UnsealGetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Grant_serviceDesc.Streams[1], "/api.Grant/UnsealGet", opts...)
	if err != nil {
		return nil, err
	}
	x := &grantUnsealGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Grant_UnsealGetClient interface {
	Recv() (*Plaintext, error)
	grpc.ClientStream
}

type grantUnsealGetClient struct {
	grpc.ClientStream
}

func (x *grantUnsealGetClient) Recv() (*Plaintext, error) {
	m := new(Plaintext)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grantClient) UnsealDelete(ctx context.Context, in *grant.Grant, opts ...grpc.CallOption) (*Address, error) {
	out := new(Address)
	err := c.cc.Invoke(ctx, "/api.Grant/UnsealDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GrantServer is the server API for Grant service.
type GrantServer interface {
	// Seal a Reference to create a Grant
	Seal(context.Context, *ReferenceAndGrantSpec) (*grant.Grant, error)
	// Unseal a Grant to recover the Reference
	Unseal(context.Context, *grant.Grant) (*reference.Ref, error)
	// Convert one grant to another grant to re-share with another party or just
	// to change grant type
	Reseal(context.Context, *GrantAndGrantSpec) (*grant.Grant, error)
	// Put a Plaintext and returned the sealed Reference as a Grant
	PutSeal(Grant_PutSealServer) error
	// Unseal a Grant and follow the Reference to return a Plaintext
	UnsealGet(*grant.Grant, Grant_UnsealGetServer) error
	// Unseal a Grant and follow the Reference to delete the Plaintext
	UnsealDelete(context.Context, *grant.Grant) (*Address, error)
}

// UnimplementedGrantServer can be embedded to have forward compatible implementations.
type UnimplementedGrantServer struct {
}

func (*UnimplementedGrantServer) Seal(ctx context.Context, req *ReferenceAndGrantSpec) (*grant.Grant, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seal not implemented")
}
func (*UnimplementedGrantServer) Unseal(ctx context.Context, req *grant.Grant) (*reference.Ref, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unseal not implemented")
}
func (*UnimplementedGrantServer) Reseal(ctx context.Context, req *GrantAndGrantSpec) (*grant.Grant, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reseal not implemented")
}
func (*UnimplementedGrantServer) PutSeal(srv Grant_PutSealServer) error {
	return status.Errorf(codes.Unimplemented, "method PutSeal not implemented")
}
func (*UnimplementedGrantServer) UnsealGet(req *grant.Grant, srv Grant_UnsealGetServer) error {
	return status.Errorf(codes.Unimplemented, "method UnsealGet not implemented")
}
func (*UnimplementedGrantServer) UnsealDelete(ctx context.Context, req *grant.Grant) (*Address, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsealDelete not implemented")
}

func RegisterGrantServer(s *grpc.Server, srv GrantServer) {
	s.RegisterService(&_Grant_serviceDesc, srv)
}

func _Grant_Seal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReferenceAndGrantSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrantServer).Seal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Grant/Seal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrantServer).Seal(ctx, req.(*ReferenceAndGrantSpec))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grant_Unseal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(grant.Grant)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrantServer).Unseal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Grant/Unseal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrantServer).Unseal(ctx, req.(*grant.Grant))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grant_Reseal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantAndGrantSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrantServer).Reseal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Grant/Reseal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrantServer).Reseal(ctx, req.(*GrantAndGrantSpec))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grant_PutSeal_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrantServer).PutSeal(&grantPutSealServer{stream})
}

type Grant_PutSealServer interface {
	SendAndClose(*grant.Grant) error
	Recv() (*PlaintextAndGrantSpec, error)
	grpc.ServerStream
}

type grantPutSealServer struct {
	grpc.ServerStream
}

func (x *grantPutSealServer) SendAndClose(m *grant.Grant) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grantPutSealServer) Recv() (*PlaintextAndGrantSpec, error) {
	m := new(PlaintextAndGrantSpec)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Grant_UnsealGet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(grant.Grant)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GrantServer).UnsealGet(m, &grantUnsealGetServer{stream})
}

type Grant_UnsealGetServer interface {
	Send(*Plaintext) error
	grpc.ServerStream
}

type grantUnsealGetServer struct {
	grpc.ServerStream
}

func (x *grantUnsealGetServer) Send(m *Plaintext) error {
	return x.ServerStream.SendMsg(m)
}

func _Grant_UnsealDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(grant.Grant)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrantServer).UnsealDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Grant/UnsealDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrantServer).UnsealDelete(ctx, req.(*grant.Grant))
	}
	return interceptor(ctx, in, info, handler)
}

var _Grant_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Grant",
	HandlerType: (*GrantServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Seal",
			Handler:    _Grant_Seal_Handler,
		},
		{
			MethodName: "Unseal",
			Handler:    _Grant_Unseal_Handler,
		},
		{
			MethodName: "Reseal",
			Handler:    _Grant_Reseal_Handler,
		},
		{
			MethodName: "UnsealDelete",
			Handler:    _Grant_UnsealDelete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutSeal",
			Handler:       _Grant_PutSeal_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UnsealGet",
			Handler:       _Grant_UnsealGet_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

// CleartextClient is the client API for Cleartext service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CleartextClient interface {
	// Push some plaintext data into storage and get its deterministically
	// generated secret reference.
	Put(ctx context.Context, opts ...grpc.CallOption) (Cleartext_PutClient, error)
	// Provide a secret reference to an encrypted blob and get the plaintext
	// data back.
	Get(ctx context.Context, in *reference.Ref, opts ...grpc.CallOption) (Cleartext_GetClient, error)
}

type cleartextClient struct {
	cc *grpc.ClientConn
}

func NewCleartextClient(cc *grpc.ClientConn) CleartextClient {
	return &cleartextClient{cc}
}

func (c *cleartextClient) Put(ctx context.Context, opts ...grpc.CallOption) (Cleartext_PutClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Cleartext_serviceDesc.Streams[0], "/api.Cleartext/Put", opts...)
	if err != nil {
		return nil, err
	}
	x := &cleartextPutClient{stream}
	return x, nil
}

type Cleartext_PutClient interface {
	Send(*Plaintext) error
	CloseAndRecv() (*reference.Ref, error)
	grpc.ClientStream
}

type cleartextPutClient struct {
	grpc.ClientStream
}

func (x *cleartextPutClient) Send(m *Plaintext) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cleartextPutClient) CloseAndRecv() (*reference.Ref, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(reference.Ref)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cleartextClient) Get(ctx context.Context, in *reference.Ref, opts ...grpc.CallOption) (Cleartext_GetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Cleartext_serviceDesc.Streams[1], "/api.Cleartext/Get", opts...)
	if err != nil {
		return nil, err
	}
	x := &cleartextGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Cleartext_GetClient interface {
	Recv() (*Plaintext, error)
	grpc.ClientStream
}

type cleartextGetClient struct {
	grpc.ClientStream
}

func (x *cleartextGetClient) Recv() (*Plaintext, error) {
	m := new(Plaintext)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CleartextServer is the server API for Cleartext service.
type CleartextServer interface {
	// Push some plaintext data into storage and get its deterministically
	// generated secret reference.
	Put(Cleartext_PutServer) error
	// Provide a secret reference to an encrypted blob and get the plaintext
	// data back.
	Get(*reference.Ref, Cleartext_GetServer) error
}

// UnimplementedCleartextServer can be embedded to have forward compatible implementations.
type UnimplementedCleartextServer struct {
}

func (*UnimplementedCleartextServer) Put(srv Cleartext_PutServer) error {
	return status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (*UnimplementedCleartextServer) Get(req *reference.Ref, srv Cleartext_GetServer) error {
	return status.Errorf(codes.Unimplemented, "method Get not implemented")
}

func RegisterCleartextServer(s *grpc.Server, srv CleartextServer) {
	s.RegisterService(&_Cleartext_serviceDesc, srv)
}

func _Cleartext_Put_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CleartextServer).Put(&cleartextPutServer{stream})
}

type Cleartext_PutServer interface {
	SendAndClose(*reference.Ref) error
	Recv() (*Plaintext, error)
	grpc.ServerStream
}

type cleartextPutServer struct {
	grpc.ServerStream
}

func (x *cleartextPutServer) SendAndClose(m *reference.Ref) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cleartextPutServer) Recv() (*Plaintext, error) {
	m := new(Plaintext)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Cleartext_Get_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(reference.Ref)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CleartextServer).Get(m, &cleartextGetServer{stream})
}

type Cleartext_GetServer interface {
	Send(*Plaintext) error
	grpc.ServerStream
}

type cleartextGetServer struct {
	grpc.ServerStream
}

func (x *cleartextGetServer) Send(m *Plaintext) error {
	return x.ServerStream.SendMsg(m)
}

var _Cleartext_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Cleartext",
	HandlerType: (*CleartextServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Put",
			Handler:       _Cleartext_Put_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Get",
			Handler:       _Cleartext_Get_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

// EncryptionClient is the client API for Encryption service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EncryptionClient interface {
	// Encrypt some data and get its deterministically generated
	// secret reference including its address without storing the data.
	Encrypt(ctx context.Context, opts ...grpc.CallOption) (Encryption_EncryptClient, error)
	// Decrypt the provided data by supplying it alongside its secret
	// reference. The address is not used for decryption and may be omitted.
	Decrypt(ctx context.Context, in *ReferenceAndCiphertext, opts ...grpc.CallOption) (Encryption_DecryptClient, error)
}

type encryptionClient struct {
	cc *grpc.ClientConn
}

func NewEncryptionClient(cc *grpc.ClientConn) EncryptionClient {
	return &encryptionClient{cc}
}

func (c *encryptionClient) Encrypt(ctx context.Context, opts ...grpc.CallOption) (Encryption_EncryptClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Encryption_serviceDesc.Streams[0], "/api.Encryption/Encrypt", opts...)
	if err != nil {
		return nil, err
	}
	x := &encryptionEncryptClient{stream}
	return x, nil
}

type Encryption_EncryptClient interface {
	Send(*Plaintext) error
	CloseAndRecv() (*ReferenceAndCiphertext, error)
	grpc.ClientStream
}

type encryptionEncryptClient struct {
	grpc.ClientStream
}

func (x *encryptionEncryptClient) Send(m *Plaintext) error {
	return x.ClientStream.SendMsg(m)
}

func (x *encryptionEncryptClient) CloseAndRecv() (*ReferenceAndCiphertext, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ReferenceAndCiphertext)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *encryptionClient) Decrypt(ctx context.Context, in *ReferenceAndCiphertext, opts ...grpc.CallOption) (Encryption_DecryptClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Encryption_serviceDesc.Streams[1], "/api.Encryption/Decrypt", opts...)
	if err != nil {
		return nil, err
	}
	x := &encryptionDecryptClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Encryption_DecryptClient interface {
	Recv() (*Plaintext, error)
	grpc.ClientStream
}

type encryptionDecryptClient struct {
	grpc.ClientStream
}

func (x *encryptionDecryptClient) Recv() (*Plaintext, error) {
	m := new(Plaintext)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EncryptionServer is the server API for Encryption service.
type EncryptionServer interface {
	// Encrypt some data and get its deterministically generated
	// secret reference including its address without storing the data.
	Encrypt(Encryption_EncryptServer) error
	// Decrypt the provided data by supplying it alongside its secret
	// reference. The address is not used for decryption and may be omitted.
	Decrypt(*ReferenceAndCiphertext, Encryption_DecryptServer) error
}

// UnimplementedEncryptionServer can be embedded to have forward compatible implementations.
type UnimplementedEncryptionServer struct {
}

func (*UnimplementedEncryptionServer) Encrypt(srv Encryption_EncryptServer) error {
	return status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (*UnimplementedEncryptionServer) Decrypt(req *ReferenceAndCiphertext, srv Encryption_DecryptServer) error {
	return status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}

func RegisterEncryptionServer(s *grpc.Server, srv EncryptionServer) {
	s.RegisterService(&_Encryption_serviceDesc, srv)
}

func _Encryption_Encrypt_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EncryptionServer).Encrypt(&encryptionEncryptServer{stream})
}

type Encryption_EncryptServer interface {
	SendAndClose(*ReferenceAndCiphertext) error
	Recv() (*Plaintext, error)
	grpc.ServerStream
}

type encryptionEncryptServer struct {
	grpc.ServerStream
}

func (x *encryptionEncryptServer) SendAndClose(m *ReferenceAndCiphertext) error {
	return x.ServerStream.SendMsg(m)
}

func (x *encryptionEncryptServer) Recv() (*Plaintext, error) {
	m := new(Plaintext)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Encryption_Decrypt_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReferenceAndCiphertext)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EncryptionServer).Decrypt(m, &encryptionDecryptServer{stream})
}

type Encryption_DecryptServer interface {
	Send(*Plaintext) error
	grpc.ServerStream
}

type encryptionDecryptServer struct {
	grpc.ServerStream
}

func (x *encryptionDecryptServer) Send(m *Plaintext) error {
	return x.ServerStream.SendMsg(m)
}

var _Encryption_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Encryption",
	HandlerType: (*EncryptionServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Encrypt",
			Handler:       _Encryption_Encrypt_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Decrypt",
			Handler:       _Encryption_Decrypt_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

// StorageClient is the client API for Storage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StorageClient interface {
	// Insert the (presumably) encrypted data provided and get the its address.
	Push(ctx context.Context, opts ...grpc.CallOption) (Storage_PushClient, error)
	// Retrieve the (presumably) encrypted data stored at address.
	Pull(ctx context.Context, in *Address, opts ...grpc.CallOption) (Storage_PullClient, error)
	// Get some information about the encrypted blob stored at an address,
	// including whether it exists.
	Stat(ctx context.Context, in *Address, opts ...grpc.CallOption) (*stores.StatInfo, error)
	// Delete the encrypted blob stored at address
	Delete(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Address, error)
}

type storageClient struct {
	cc *grpc.ClientConn
}

func NewStorageClient(cc *grpc.ClientConn) StorageClient {
	return &storageClient{cc}
}

func (c *storageClient) Push(ctx context.Context, opts ...grpc.CallOption) (Storage_PushClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Storage_serviceDesc.Streams[0], "/api.Storage/Push", opts...)
	if err != nil {
		return nil, err
	}
	x := &storagePushClient{stream}
	return x, nil
}

type Storage_PushClient interface {
	Send(*Ciphertext) error
	CloseAndRecv() (*Address, error)
	grpc.ClientStream
}

type storagePushClient struct {
	grpc.ClientStream
}

func (x *storagePushClient) Send(m *Ciphertext) error {
	return x.ClientStream.SendMsg(m)
}

func (x *storagePushClient) CloseAndRecv() (*Address, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Address)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) Pull(ctx context.Context, in *Address, opts ...grpc.CallOption) (Storage_PullClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Storage_serviceDesc.Streams[1], "/api.Storage/Pull", opts...)
	if err != nil {
		return nil, err
	}
	x := &storagePullClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Storage_PullClient interface {
	Recv() (*Ciphertext, error)
	grpc.ClientStream
}

type storagePullClient struct {
	grpc.ClientStream
}

func (x *storagePullClient) Recv() (*Ciphertext, error) {
	m := new(Ciphertext)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) Stat(ctx context.Context, in *Address, opts ...grpc.CallOption) (*stores.StatInfo, error) {
	out := new(stores.StatInfo)
	err := c.cc.Invoke(ctx, "/api.Storage/Stat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Delete(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Address, error) {
	out := new(Address)
	err := c.cc.Invoke(ctx, "/api.Storage/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StorageServer is the server API for Storage service.
type StorageServer interface {
	// Insert the (presumably) encrypted data provided and get the its address.
	Push(Storage_PushServer) error
	// Retrieve the (presumably) encrypted data stored at address.
	Pull(*Address, Storage_PullServer) error
	// Get some information about the encrypted blob stored at an address,
	// including whether it exists.
	Stat(context.Context, *Address) (*stores.StatInfo, error)
	// Delete the encrypted blob stored at address
	Delete(context.Context, *Address) (*Address, error)
}

// UnimplementedStorageServer can be embedded to have forward compatible implementations.
type UnimplementedStorageServer struct {
}

func (*UnimplementedStorageServer) Push(srv Storage_PushServer) error {
	return status.Errorf(codes.Unimplemented, "method Push not implemented")
}
func (*UnimplementedStorageServer) Pull(req *Address, srv Storage_PullServer) error {
	return status.Errorf(codes.Unimplemented, "method Pull not implemented")
}
func (*UnimplementedStorageServer) Stat(ctx context.Context, req *Address) (*stores.StatInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stat not implemented")
}
func (*UnimplementedStorageServer) Delete(ctx context.Context, req *Address) (*Address, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}

func RegisterStorageServer(s *grpc.Server, srv StorageServer) {
	s.RegisterService(&_Storage_serviceDesc, srv)
}

func _Storage_Push_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StorageServer).Push(&storagePushServer{stream})
}

type Storage_PushServer interface {
	SendAndClose(*Address) error
	Recv() (*Ciphertext, error)
	grpc.ServerStream
}

type storagePushServer struct {
	grpc.ServerStream
}

func (x *storagePushServer) SendAndClose(m *Address) error {
	return x.ServerStream.SendMsg(m)
}

func (x *storagePushServer) Recv() (*Ciphertext, error) {
	m := new(Ciphertext)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Storage_Pull_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Address)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServer).Pull(m, &storagePullServer{stream})
}

type Storage_PullServer interface {
	Send(*Ciphertext) error
	grpc.ServerStream
}

type storagePullServer struct {
	grpc.ServerStream
}

func (x *storagePullServer) Send(m *Ciphertext) error {
	return x.ServerStream.SendMsg(m)
}

func _Storage_Stat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).Stat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/Stat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).Stat(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).Delete(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

var _Storage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Storage",
	HandlerType: (*StorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Stat",
			Handler:    _Storage_Stat_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Storage_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Push",
			Handler:       _Storage_Push_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Pull",
			Handler:       _Storage_Pull_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}
