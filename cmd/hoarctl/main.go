package main

import (
	"os"

	"github.com/monax/hoard/grant"

	"github.com/monax/hoard/reference"

	"github.com/monax/hoard"

	"context"
	"io/ioutil"

	"fmt"

	"net"
	"time"

	"encoding/json"

	"io"

	"encoding/base64"

	cli "github.com/jawher/mow.cli"
	"github.com/monax/hoard/cmd"
	"github.com/monax/hoard/config"
	"github.com/monax/hoard/server"
	"google.golang.org/grpc"
)

const (
	addrOpt string = "The address of the data to retrieve as base64-encoded string"
	getOpt  string = "Get encrypted sealed data and write it to STDOUT"
	putOpt  string = "Read plaintext data from STDIN instead"
	saltOpt string = "Token to use for encryption and decryption. " +
		"Will be parsed as base64 encoded string if this is possible, " +
		"otherwise will be interpreted as the bytes of the string itself."
	secretOpt string = "The secret key to decrypt the data with as base64-encoded string."
)

func main() {
	hoarctlApp := cli.App("hoarctl",
		"Command line interface to the hoard daemon a content-addressed "+
			"deterministically encrypted blob storage system")

	dialURL := hoarctlApp.StringOpt("a address", config.DefaultListenAddress,
		"local address on which hoard is listening encoded as a URL with the "+
			"network protocol as the scheme, for example 'tcp://localhost:54192' "+
			"or 'unix:///tmp/hoard.sock'")

	// Scope a few variables to this lexical scope
	var cleartextClient hoard.CleartextClient
	var encryptionClient hoard.EncryptionClient
	var grantClient hoard.GrantClient
	var storageClient hoard.StorageClient
	var conn *grpc.ClientConn

	hoarctlApp.Before = func() {
		netProtocol, localAddress, err := server.SplitListenURL(*dialURL)

		conn, err = grpc.Dial(*dialURL,
			grpc.WithInsecure(),
			// We have to bugger around with this so we can dial an arbitrary net.Conn
			grpc.WithDialer(func(string, time.Duration) (net.Conn, error) {
				return net.Dial(netProtocol, localAddress)
			}))

		if err != nil {
			fatalf("could not dial hoard server on %s: %v", *dialURL, err)
		}
		cleartextClient = hoard.NewCleartextClient(conn)
		encryptionClient = hoard.NewEncryptionClient(conn)
		grantClient = hoard.NewGrantClient(conn)
		storageClient = hoard.NewStorageClient(conn)
	}

	cmd.AddVersionCommand(hoarctlApp)

	hoarctlApp.Command("put",
		"Put some data read from STDIN into encrypted data store and return a reference on STDOUT",
		func(cmd *cli.Cmd) {
			salt := addOpt(cmd, "salt", saltOpt, "").(*string)

			cmd.Action = func() {
				data := readData()
				ref, err := cleartextClient.Put(context.Background(),
					&hoard.Plaintext{
						Data: data,
						Salt: parseSalt(*salt),
					})
				if err != nil {
					fatalf("error storing data: %v", err)
				}
				fmt.Printf("%s\n", jsonString(ref))
			}
		})

	hoarctlApp.Command("get",
		"Get some data from encrypted data store and write it to STDOUT - "+
			"must have the JSON reference to the object passed in on STDIN (as "+
			"generated by ref or put) or the ADDRESS and SECRET_KEY provided",
		func(cmd *cli.Cmd) {
			address := addOpt(cmd, "address", addrOpt, "").(*string)
			secretKey := addOpt(cmd, "key", secretOpt, "").(*string)
			salt := addOpt(cmd, "salt", saltOpt, "").(*string)

			cmd.Action = func() {
				// If given address then try to read reference from arguments and option
				ref := readReference(address)
				if ref.SecretKey == nil {
					if secretKey == nil || *secretKey == "" {
						fatalf("a secret key must be provided in order to decrypt")
					}
					ref = &reference.Ref{
						Address:   readBase64(*address),
						SecretKey: readBase64(*secretKey),
						Salt:      parseSalt(*salt),
					}
				}
				plaintext, err := cleartextClient.Get(context.Background(), ref)
				if err != nil {
					fatalf("error retrieving data: %v", err)
				}
				os.Stdout.Write(plaintext.Data)
			}
		})

	hoarctlApp.Command("ref",
		"Encrypt data from STDIN and return its reference",
		func(cmd *cli.Cmd) {
			salt := addOpt(cmd, "salt", saltOpt, "").(*string)

			cmd.Action = func() {
				data := readData()
				refAndCiphertext, err := encryptionClient.Encrypt(context.Background(),
					&hoard.Plaintext{
						Data: data,
						Salt: parseSalt(*salt),
					})
				if err != nil {
					fatalf("error generating reference: %v", err)
				}
				fmt.Printf("%s\n", jsonString(refAndCiphertext.Reference))
			}
		})

	hoarctlApp.Command("encrypt",
		"Encrypt data from STDIN and output encrypted data on STDOUT",
		func(cmd *cli.Cmd) {
			salt := addOpt(cmd, "salt", saltOpt, "").(*string)

			cmd.Action = func() {
				data, err := ioutil.ReadAll(os.Stdin)
				if err != nil {
					fatalf("could read bytes from STDIN to store: %v", err)
				}
				refAndCiphertext, err := encryptionClient.Encrypt(context.Background(),
					&hoard.Plaintext{
						Data: data,
						Salt: parseSalt(*salt),
					})
				if err != nil {
					fatalf("error encrypting: %v", err)
				}
				os.Stdout.Write(refAndCiphertext.Ciphertext.EncryptedData)
			}
		})

	hoarctlApp.Command("decrypt",
		"Decrypt data from STDIN and output decrypted data on STDOUT",
		func(cmd *cli.Cmd) {
			secretKey := addOpt(cmd, "key", secretOpt, "").(*string)
			salt := addOpt(cmd, "salt", saltOpt, "").(*string)

			cmd.Action = func() {
				encryptedData := readData()
				plaintext, err := encryptionClient.Decrypt(context.Background(),
					&hoard.ReferenceAndCiphertext{
						Reference: &reference.Ref{
							SecretKey: readBase64(*secretKey),
							Salt:      parseSalt(*salt),
						},
						Ciphertext: &hoard.Ciphertext{
							EncryptedData: encryptedData,
						},
					})
				if err != nil {
					fatalf("error decrypting: %v", err)
				}
				os.Stdout.Write(plaintext.Data)
			}
		})

	hoarctlApp.Command("stat",
		"Get information about the encrypted blob stored as an address from "+
			"a reference passed in on STDIN or passed as in as a single argument "+
			"as a base64 encoded string",
		func(cmd *cli.Cmd) {
			address := addOpt(cmd, "address", addrOpt, "").(*string)

			cmd.Action = func() {
				ref := readReference(address)
				statInfo, err := storageClient.Stat(context.Background(),
					&hoard.Address{Address: ref.Address})
				if err != nil {
					fatalf("error querying data: %v", err)
				}
				fmt.Printf("%s\n", jsonString(statInfo))
			}
		})

	hoarctlApp.Command("insert",
		"Insert (presumably) encrypted data on STDIN directly into store at "+
			"its address which is written to STDOUT",
		func(cmd *cli.Cmd) {
			cmd.Action = func() {
				data := readData()
				// If given address use it
				address, err := storageClient.Push(context.Background(),
					&hoard.Ciphertext{EncryptedData: data})
				if err != nil {
					fatalf("error querying data: %v", err)
				}
				fmt.Printf("%s\n", jsonString(address))
			}
		})

	hoarctlApp.Command("cat",
		"Retrieve the encrypted blob stored as an address from "+
			"a reference passed in on STDIN or passed as in as a single argument "+
			"as a base64 encoded string",
		func(cmd *cli.Cmd) {
			address := addOpt(cmd, "address", addrOpt, "").(*string)

			cmd.Action = func() {
				ref := readReference(address)
				ciphertext, err := storageClient.Pull(context.Background(),
					&hoard.Address{Address: ref.Address})
				if err != nil {
					fatalf("error querying data: %v", err)
				}
				os.Stdout.Write(ciphertext.EncryptedData)
			}
		})

	hoarctlApp.Command("seal",
		"Seal some data read from STDIN and return grant to STDOUT",
		func(cmd *cli.Cmd) {
			address := addOpt(cmd, "address", addrOpt, "").(*string)
			put := addOpt(cmd, "put", putOpt, false).(*bool)
			salt := addOpt(cmd, "salt", saltOpt, "").(*string)
			key := addOpt(cmd, "key", saltOpt, "").(*string)

			cmd.Action = func() {

				var seal *grant.Grant
				var err error

				spec := grant.Spec{Plaintext: &grant.PlaintextSpec{}}
				if key != nil {
					spec = grant.Spec{
						Plaintext: nil,
						Symmetric: &grant.SymmetricSpec{SecretID: string(parseSalt(*key))},
					}
				}

				if *put {
					data := readData()
					seal, err = grantClient.PutSeal(context.Background(),
						&hoard.PlaintextAndGrantSpec{
							Plaintext: &hoard.Plaintext{
								Data: data,
								Salt: parseSalt(*salt),
							},
							GrantSpec: &spec,
						},
					)
				} else {
					ref := readReference(address)
					seal, err = grantClient.Seal(context.Background(),
						&hoard.ReferenceAndGrantSpec{
							Reference: ref,
							GrantSpec: &grant.Spec{Plaintext: &grant.PlaintextSpec{}},
						},
					)
				}

				if err != nil {
					fatalf("error sealing data: %v", err)
				}
				fmt.Printf("%s\n", jsonString(seal))
			}
		})

	hoarctlApp.Command("unseal",
		"Unseal grant read from STDIN and print data to STDOUT",
		func(cmd *cli.Cmd) {
			get := addOpt(cmd, "get", getOpt, false).(*bool)

			cmd.Action = func() {
				grt := readGrant()

				if *get {
					plaintext, err := grantClient.UnsealGet(context.Background(), grt)
					if err != nil {
						fatalf("error unsealing data: %v", err)
					}
					os.Stdout.Write(plaintext.Data)
					return
				}

				ref, err := grantClient.Unseal(context.Background(), grt)
				if err != nil {
					fatalf("error unsealing data: %v", err)
				}
				fmt.Printf("%s\n", jsonString(ref))
			}
		})

	hoarctlApp.Command("reseal",
		"Reseal grant read from STDIN and print new grant to STDOUT",
		func(cmd *cli.Cmd) {
			salt := addOpt(cmd, "salt", saltOpt, "").(*string)

			cmd.Action = func() {
				prev := readGrant()
				next := grant.Spec{Plaintext: &grant.PlaintextSpec{}}

				if salt != nil {
					next = grant.Spec{
						Plaintext: nil,
						Symmetric: &grant.SymmetricSpec{SecretID: string(parseSalt(*salt))},
					}
				}

				ref, err := grantClient.Reseal(context.Background(),
					&hoard.GrantAndGrantSpec{
						Grant:     prev,
						GrantSpec: &next,
					})
				if err != nil {
					fatalf("error resealing data: %v", err)
				}
				fmt.Printf("%s\n", jsonString(ref))
			}
		})

	hoarctlApp.Run(os.Args)
}

// extra cli options
func addOpt(cmd *cli.Cmd, arg, desc string, def interface{}) (opt interface{}) {
	switch d := def.(type) {
	case string:
		opt = cmd.StringOpt(fmt.Sprintf("%s %s", string(arg[0]), arg), d, desc)
	case bool:
		opt = cmd.BoolOpt(fmt.Sprintf("%s %s", string(arg[0]), arg), d, desc)
	}
	cmd.Spec += fmt.Sprintf("[-%s | --%s]", string(arg[0]), arg)
	return opt
}

func parseSalt(saltString string) []byte {
	if saltString == "" {
		return nil
	}
	saltBytes, err := base64.StdEncoding.DecodeString(saltString)
	if err == nil {
		return saltBytes
	}
	return ([]byte)(saltString)
}

func jsonString(v interface{}) string {
	bs, err := json.Marshal(v)
	if err != nil {
		fatalf("could not serialise '%s' to json: %v", err)
	}
	return string(bs)

}

func readData() []byte {
	data, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		fatalf("could not read bytes from STDIN to store: %v", err)
	}
	return data
}

func readReference(address *string) *reference.Ref {
	ref := new(reference.Ref)
	if address != nil && *address != "" {
		ref.Address = readBase64(*address)
		return ref
	}
	err := parseObject(os.Stdin, ref)
	if err != nil {
		fatalf("could not read reference from STDIN: %v", err)
	}
	return ref
}

func readGrant() *grant.Grant {
	grt := new(grant.Grant)
	err := parseObject(os.Stdin, grt)
	if err != nil {
		fatalf("could not read grant from STDIN: %v", err)
	}
	return grt
}

func parseObject(r io.Reader, o interface{}) error {
	bs, err := ioutil.ReadAll(r)
	if err != nil {
		return err
	}
	err = json.Unmarshal(bs, o)
	if err != nil {
		return err
	}
	return nil
}

func readBase64(base64String string) []byte {
	secretKeyBytes, err := base64.StdEncoding.DecodeString(base64String)
	if err != nil {
		fatalf("could not decode '%s' as base64-encoded string", base64String)
	}
	return secretKeyBytes
}

func fatalf(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format+"\n", args...)
	os.Exit(1)
}
